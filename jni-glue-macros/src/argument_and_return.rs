use crate::escape::java_fqn_class_name_to_c_identifier;
use quote::quote;
use proc_macro2::*;
use std::borrow::Cow;
use std::convert::*;


pub struct Argument {
    pub name:   Ident,
    jtt:        JavaTypedThing,
}

impl std::ops::Deref for Argument {
    type Target = JavaTypedThing;
    fn deref(&self) -> &Self::Target { &self.jtt }
}

impl Argument {
    pub fn new(name: Ident, fqn_java_type: String) -> Self {
        // TODO: Resultify?
        debug_assert!(!format!("{}", name).contains("."), "Argument name contains '.' (did you mix up the name and the type?)");
        debug_assert!(!format!("{}", name).contains("$"), "Argument name contains '$' (did you mix up the name and the type?)");
        // Forbid "void" too?

        Self {
            name,
            jtt: JavaTypedThing::new(fqn_java_type),
        }
    }
}



pub struct Return {
    jtt: JavaTypedThing,
}

impl std::ops::Deref for Return {
    type Target = JavaTypedThing;
    fn deref(&self) -> &Self::Target { &self.jtt }
}

impl Return {
    pub fn new(fqn_java_type: String) -> Self {
        Self { jtt: JavaTypedThing::new(fqn_java_type) }
    }
}



pub struct JavaTypedThing {
    pub fqn_java_type:  String,
    pub jni:            Cow<'static, str>,
    pub outer:          TokenStream,
    pub inner:          TokenStream,
    pub outer_to_inner: Convert,
    pub inner_to_outer: Convert,
}

impl JavaTypedThing {
    pub fn new(fqn_java_type: String) -> Self {
        let                (jni, outer,                         inner,                      outer_to_inner, inner_to_outer    ) = match fqn_java_type.as_str() {
            "void"      => ("V", quote!{()},                    quote!{()},                 noop as _,      noop as _         ),
            "bool"      => ("Z", quote!{::jni_sys::jboolean},   quote!{bool},               as_bool as _,   as_jboolean as _  ), // XXX: Just being paranoid here
            "byte"      => ("B", quote!{::jni_sys::jbyte},      quote!{i8},                 noop as _,      noop as _         ),
            "char"      => ("C", quote!{::jni_glue::jchar},     quote!{::jni_glue::jchar},  noop as _,      noop as _         ), // {jni_sys,jni_glue}::jchar are ABI compatible
            "short"     => ("S", quote!{::jni_sys::jshort},     quote!{i16},                noop as _,      noop as _         ),
            "int"       => ("I", quote!{::jni_sys::jint},       quote!{i32},                noop as _,      noop as _         ),
            "long"      => ("J", quote!{::jni_sys::jlong},      quote!{i64},                noop as _,      noop as _         ),
            "float"     => ("F", quote!{::jni_sys::jfloat},     quote!{f32},                noop as _,      noop as _         ),
            "double"    => ("D", quote!{::jni_sys::jdouble},    quote!{f64},                noop as _,      noop as _         ),
            _ => {
                let mut jni = String::new();
                jni.push('L');
                jni.push_str(&java_fqn_class_name_to_c_identifier(fqn_java_type.as_str()));
                jni.push_str("_2"); // ;

                // Okay, for now, let's blindly generate an non-absolute path.  The user can decide how they want to
                // resolve, say, `java::lang::String`, via:
                // 
                //      use jni_android_sys::java;
                // 
                // Or:
                // 
                //      use jni_java_sys::java;
                // 
                // Or even:
                // 
                //      mod java {
                //          pub mod lang {
                //              use jni_java_sys::java::lang::*;
                //              use jni_android_sys::java::lang::{SomethingSpecific};
                //              pub struct String { ... }
                //          }
                //      }
                let mut class = TokenStream::new();
                for (i, component) in fqn_java_type.split('.').enumerate() {
                    if i != 0 { class.extend(quote!{::}); }
                    let component = Ident::new(component.replace("$", "_").as_str(), Span::call_site());
                    class.extend(quote!{#component});
                }

                let outer = quote!{        ::jni_glue::Argument   <      #class>  };
                let inner = quote!{ Option<::jni_glue::ArgumentRef<'env, #class>> };

                // let key_event = unsafe { key_event.with_unchecked(env) }; // Unsafe boilerplate not yet autogenerated.
                return Self {
                    fqn_java_type,
                    jni: jni.into(),
                    outer,
                    inner,
                    outer_to_inner: Convert::Ptr(nyi), // TODO: Implement
                    inner_to_outer: Convert::Ptr(nyi), // TODO: Implement
                };
            },
        };

        Self {
            fqn_java_type,
            jni:            jni.into(),
            outer:          outer.into(),
            inner:          inner.into(),
            outer_to_inner: Convert::Ptr(outer_to_inner),
            inner_to_outer: Convert::Ptr(inner_to_outer),
        }
    }
}

impl std::fmt::Debug for Argument {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            fmt,
            "Argument {{ name: {:?}, fqn_java_type: {:?}, jni: {:?}, outer: \"{}\", inner: \"{}\", ... }}",
            self.name.to_string(),
            self.fqn_java_type,
            &*self.jni,
            self.outer,
            self.inner
        )
    }
}



pub enum Convert {
    Ptr(fn(Ident) -> TokenStream),
    Box(Box<dyn Fn(Ident) -> TokenStream>),
}

impl From<fn(Ident) -> TokenStream          > for Convert { fn from(value: fn(Ident) -> TokenStream         ) -> Self { Convert::Ptr(value) } }
impl From<Box<dyn Fn(Ident) -> TokenStream> > for Convert { fn from(value: Box<dyn Fn(Ident) -> TokenStream>) -> Self { Convert::Box(value) } }
impl std::fmt::Debug for Convert { fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result { write!(fmt, "Convert") } }

fn noop         (ident: Ident) -> TokenStream { quote!{#ident} }
fn as_bool      (ident: Ident) -> TokenStream { quote!{#ident as bool} }
fn as_jboolean  (ident: Ident) -> TokenStream { quote!{#ident as ::jni_sys::jboolean} }
fn nyi          (_iden: Ident) -> TokenStream { unimplemented!() }
